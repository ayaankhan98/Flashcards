{"version":3,"sources":["cardeditor.js","cardviewer.js","App.js","serviceWorker.js","index.js"],"names":["CardEditor","props","handleChange","event","setState","target","name","value","addCard","state","front","back","deleteCard","index","dataset","rows","this","cards","map","card","i","key","data-index","onClick","onChange","placeholder","switchMode","React","Component","CardViewer","App","editor","splice","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"2RAoEeA,G,kBAhEX,WAAYC,GAAQ,IAAD,8BACf,4CAAMA,KA0CVC,aAAe,SAACC,GACZ,EAAKC,SAAL,eACKD,EAAME,OAAOC,KAAQH,EAAME,OAAOE,SA7CxB,EAiDnBC,QAAU,WACN,EAAKP,MAAMO,QAAQ,EAAKC,MAAMC,MAAO,EAAKD,MAAME,MAChD,EAAKP,SAAS,CACVM,MAAQ,GACRC,KAAO,MArDI,EAyDnBC,WAAa,SAACT,GACV,IAAMU,EAAQV,EAAME,OAAOS,QAAQD,MACnC,EAAKZ,MAAMW,WAAWC,IAzDtB,EAAKJ,MAAQ,CACTC,MAAQ,GACRC,KAAO,IAJI,E,sEAQR,IAAD,OACAI,EAAOC,KAAKf,MAAMgB,MAAMC,KAAI,SAACC,EAAMC,GACrC,OACI,wBAAIC,IAAKD,GACL,4BAAKD,EAAKT,OACV,4BAAKS,EAAKR,MACV,4BAAI,4BAAQW,aAAYF,EAAGG,QAAS,EAAKX,YAArC,YAIhB,OACI,6BACI,mDACA,+BACI,+BACI,4BACI,qCACA,oCACA,wCAGR,+BACKG,IAGT,6BACA,2BAAOS,SAAUR,KAAKd,aAAcI,KAAK,QAAQmB,YAAY,gBAAgBlB,MAAOS,KAAKP,MAAMC,QAC/F,2BAAOc,SAAUR,KAAKd,aAAcI,KAAK,OAAOmB,YAAY,eAAelB,MAAOS,KAAKP,MAAME,OAC7F,4BAAQY,QAASP,KAAKR,SAAtB,YACA,6BACA,4BAAQe,QAASP,KAAKf,MAAMyB,YAA5B,yB,GAxCSC,IAAMC,YCahBC,E,iLAVP,OACI,6BACI,mDACA,6BACA,4BAAQN,QAASP,KAAKf,MAAMyB,YAA5B,yB,GAPSC,IAAMC,WCoDhBE,E,YA/Cb,WAAY7B,GAAQ,IAAD,8BACf,4CAAMA,KAuBVyB,WAAa,WACT,EAAKtB,UAAS,SAAAK,GAAK,MAAK,CACpBsB,QAAStB,EAAMsB,YA1BJ,EA8BnBvB,QAAU,SAACE,EAAOC,GACd,EAAKP,UAAS,SAAAK,GAAK,MAAK,CACpBQ,MAAK,sBAAOR,EAAMQ,OAAb,CAAmB,CAACP,QAAOC,eAhCrB,EAoCnBC,WAAa,SAACC,GACV,EAAKT,UAAS,SAAAK,GACV,IAAMQ,EAAK,YAAOR,EAAMQ,OAExB,OADAA,EAAMe,OAAOnB,EAAM,GACZ,CACHI,MAAQA,OAvChB,EAAKR,MAAQ,CACTsB,QAAS,EACTd,MAAQ,IAJG,E,sEASf,OAAID,KAAKP,MAAMsB,OACH,kBAAC,EAAD,CACId,MAASD,KAAKP,MAAMQ,MACpBS,WAAYV,KAAKU,WACjBlB,QAASQ,KAAKR,QACdI,WAAcI,KAAKJ,aAGvB,kBAAC,EAAD,CACIK,MAASD,KAAKP,MAAMQ,MACpBS,WAAYV,KAAKU,iB,GArBrBC,IAAMC,WCOJK,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.3231031b.chunk.js","sourcesContent":["import React from 'react';\nimport './App.css'\nclass CardEditor extends React.Component {\n\n    constructor(props) {\n        super(props)\n        this.state = {\n            front : \"\",\n            back : \"\",\n        }\n    }\n    \n    render () {\n        const rows = this.props.cards.map((card, i) => {\n            return (\n                <tr key={i}>\n                    <td>{card.front}</td>\n                    <td>{card.back}</td>\n                    <td><button data-index={i} onClick={this.deleteCard}>Del</button></td>\n                </tr>\n            )\n        })\n        return (\n            <div>\n                <h2> This is the Editor</h2>\n                <table>\n                    <thead>\n                        <tr>\n                            <th>Front</th>\n                            <th>Back</th>\n                            <th>Delete</th>\n                        </tr>\n                    </thead>\n                    <tbody>\n                        {rows}\n                    </tbody>\n                </table>\n                <br/>\n                <input onChange={this.handleChange} name=\"front\" placeholder=\"Front of Card\" value={this.state.front} />\n                <input onChange={this.handleChange} name=\"back\" placeholder=\"Back of Card\" value={this.state.back} />\n                <button onClick={this.addCard}>Add Card</button>\n                <hr/>\n                <button onClick={this.props.switchMode}>Switch to Viewer</button>\n            </div>\n        )\n    }\n\n    handleChange = (event) => {\n        this.setState({\n            [event.target.name] : event.target.value,\n        })\n    } \n\n    addCard = () => {\n        this.props.addCard(this.state.front, this.state.back)\n        this.setState({\n            front : \"\",\n            back : \"\",\n        })\n    }\n\n    deleteCard = (event) => {\n        const index = event.target.dataset.index\n        this.props.deleteCard(index)\n    }\n\n}\n\nexport default CardEditor","import React from 'react';\n\nclass CardViewer extends React.Component {\n\n    render () {\n        return (\n            <div>\n                <h2> This is the Viewer</h2>\n                <hr/>\n                <button onClick={this.props.switchMode}>Switch to Editor</button>\n            </div>\n        )\n    }\n}\n\nexport default CardViewer","import React from 'react';\nimport CardEditor from './cardeditor'\nimport CardViewer from './cardviewer'\n\n\nclass App extends React.Component {\n\n  constructor(props) {\n      super(props)\n      this.state = {\n          editor : true,\n          cards : [],\n          }\n  }\n\n  render() {\n      if (this.state.editor){\n          return (<CardEditor \n                      cards = {this.state.cards}\n                      switchMode={this.switchMode}\n                      addCard={this.addCard}\n                      deleteCard = {this.deleteCard} \n                  />)\n      } else {\n          return (<CardViewer \n                      cards = {this.state.cards}\n                      switchMode={this.switchMode} \n                  />)\n      }\n  }\n\n  switchMode = () => {\n      this.setState(state => ({\n          editor: !state.editor,\n      }))\n  }\n\n  addCard = (front, back) => {\n      this.setState(state => ({\n          cards : [...state.cards,{front, back}],\n      }))\n  }\n\n  deleteCard = (index) => {\n      this.setState(state => {\n          const cards = [...state.cards]\n          cards.splice(index,1)\n          return {\n              cards : cards\n          }\n      })\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}